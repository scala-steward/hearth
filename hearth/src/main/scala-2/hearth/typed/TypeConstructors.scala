package hearth
package typed

import hearth.cq.CrossQuotesMacros
import scala.language.experimental.macros

private[typed] trait TypeConstructors { this: MacroCommons =>

  trait Ctors { this: Type.type =>
    // format: off

    /* Type constructors for some common types.
      
    The code below was not written by hand, but generated by a script. Then updated with AI.
    */

    final type Ctor1[HKT[_]] = Ctor1.Bounded[Nothing, Any, HKT]
    object Ctor1 {

      def of[HKT[_]]: Ctor1[HKT] = macro CrossQuotesMacros.typeCtor1Impl[Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1` */
      trait Bounded[L1, U1 >: L1, HKT[_ >: L1 <: U1]] {

        def apply[A >: L1 <: U1: Type]: Type[HKT[A]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1)]
        /** Returns the underlying untyped type constructor representation. */
        def asUntyped: UntypedType = Ctor1.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type[HKT[A]] = apply[A]
      }
      object Bounded {
        /** Reflectively reads the private `HKT` field from macro-generated anonymous Bounded classes.
          * This is necessary because Scala 2 macro-generated quasiquotes cannot reference the `UntypedType`
          * type alias, so the `asUntyped` method cannot be overridden in the generated code.
          */
        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, HKT[_ >: L1 <: U1]]: Bounded[L1, U1, HKT] = macro CrossQuotesMacros.typeCtor1Impl[L1, U1, HKT]
      }

      final type UpperBounded[U1, HKT[_ <: U1]] = Bounded[Nothing, U1, HKT]
      object UpperBounded {

        def of[U1, HKT[_ <: U1]]: UpperBounded[U1, HKT] = macro CrossQuotesMacros.typeCtor1Impl[Nothing, U1, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, HKT[_ >: L1 <: U1], A >: L1 <: U1] = HKT[A]
      type Stub[L1, U1 >: L1, HKT[_ >: L1 <: U1]] = HKT[?]
    }

    final type Ctor2[HKT[_, _]] = Ctor2.Bounded[Nothing, Any, Nothing, Any, HKT]
    object Ctor2 {

      def of[HKT[_, _]]: Ctor2[HKT] = macro CrossQuotesMacros.typeCtor2Impl[Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type]: Type[HKT[A, B]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2)]
        def asUntyped: UntypedType = Ctor2.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor1.Bounded[L2, U2, Lambda[`B >: L2 <: U2` => HKT[A, B]]] = new Type.Ctor1.Bounded[L2, U2, Lambda[`B >: L2 <: U2` => HKT[A, B]]] {
          def apply[B >: L2 <: U2: Type]: Type[HKT[A, B]] = ctor.apply[A, B]
          def unapply[In](In: Type[In]): Option[L2 <:??<: U2] = ctor.unapply(In).collect {
            case (l1, l2) if l1.Underlying =:= Type[A] => l2
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor1.Bounded[L1, U1, Lambda[`A >: L1 <: U1` => HKT[A, B]]] = new Type.Ctor1.Bounded[L1, U1, Lambda[`A >: L1 <: U1` => HKT[A, B]]] {
          def apply[A >: L1 <: U1: Type]: Type[HKT[A, B]] = ctor.apply[A, B]
          def unapply[In](In: Type[In]): Option[L1 <:??<: U1] = ctor.unapply(In).collect {
            case (l1, l2) if l2.Underlying =:= Type[B] => l1
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {
        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2]]: Bounded[L1, U1, L2, U2, HKT] = macro CrossQuotesMacros.typeCtor2Impl[L1, U1, L2, U2, HKT]
      }

      final type UpperBounded[U1, U2, HKT[_ <: U1, _ <: U2]] = Bounded[Nothing, U1, Nothing, U2, HKT]
      object UpperBounded {

        def of[U1, U2, HKT[_ <: U1, _ <: U2]]: UpperBounded[U1, U2, HKT] = macro CrossQuotesMacros.typeCtor2Impl[Nothing, U1, Nothing, U2, HKT]
      }

			// Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
			// But using a type alias and applying values to it finished without c.typecheck errors.
			type Apply[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2], A >: L1 <: U1, B >: L2 <: U2] = HKT[A, B]
			type Stub[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2]] = HKT[?, ?]
    }

    final type Ctor3[HKT[_, _, _]] = Ctor3.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor3 {

      def of[HKT[_, _, _]]: Ctor3[HKT] = macro CrossQuotesMacros.typeCtor3Impl[Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3)]
        def asUntyped: UntypedType = Ctor3.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor2.Bounded[L2, U2, L3, U3, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`) => HKT[A, B, C]]] = new Type.Ctor2.Bounded[L2, U2, L3, U3, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`) => HKT[A, B, C]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l1.Underlying =:= Type[A] => (l2, l3)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor2.Bounded[L1, U1, L3, U3, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`) => HKT[A, B, C]]] = new Type.Ctor2.Bounded[L1, U1, L3, U3, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`) => HKT[A, B, C]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l2.Underlying =:= Type[B] => (l1, l3)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor2.Bounded[L1, U1, L2, U2, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`) => HKT[A, B, C]]] = new Type.Ctor2.Bounded[L1, U1, L2, U2, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`) => HKT[A, B, C]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l3.Underlying =:= Type[C] => (l1, l2)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {
        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]]: Bounded[L1, U1, L2, U2, L3, U3, HKT] = macro CrossQuotesMacros.typeCtor3Impl[L1, U1, L2, U2, L3, U3, HKT]
      }

      final type UpperBounded[U1, U2, U3, HKT[_ <: U1, _ <: U2, _ <: U3]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, HKT]
      object UpperBounded {

        def of[U1, U2, U3, HKT[_ <: U1, _ <: U2, _ <: U3]]: UpperBounded[U1, U2, U3, HKT] = macro CrossQuotesMacros.typeCtor3Impl[Nothing, U1, Nothing, U2, Nothing, U3, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3] = HKT[A, B, C]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]] = HKT[?, ?, ?]
    }

    final type Ctor4[HKT[_, _, _, _]] = Ctor4.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor4 {

      def of[HKT[_, _, _, _]]: Ctor4[HKT] = macro CrossQuotesMacros.typeCtor4Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)]
        def asUntyped: UntypedType = Ctor4.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor3.Bounded[L2, U2, L3, U3, L4, U4, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] = new Type.Ctor3.Bounded[L2, U2, L3, U3, L4, U4, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l1.Underlying =:= Type[A] => (l2, l3, l4)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor3.Bounded[L1, U1, L3, U3, L4, U4, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] = new Type.Ctor3.Bounded[L1, U1, L3, U3, L4, U4, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l2.Underlying =:= Type[B] => (l1, l3, l4)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor3.Bounded[L1, U1, L2, U2, L4, U4, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] = new Type.Ctor3.Bounded[L1, U1, L2, U2, L4, U4, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`) => HKT[A, B, C, D]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l3.Underlying =:= Type[C] => (l1, l2, l4)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor3.Bounded[L1, U1, L2, U2, L3, U3, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`) => HKT[A, B, C, D]]] = new Type.Ctor3.Bounded[L1, U1, L2, U2, L3, U3, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`) => HKT[A, B, C, D]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l4.Underlying =:= Type[D] => (l1, l2, l3)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, HKT] = macro CrossQuotesMacros.typeCtor4Impl[L1, U1, L2, U2, L3, U3, L4, U4, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4]]: UpperBounded[U1, U2, U3, U4, HKT] = macro CrossQuotesMacros.typeCtor4Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4] = HKT[A, B, C, D]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]] = HKT[?, ?, ?, ?]
    }

    final type Ctor5[HKT[_, _, _, _, _]] = Ctor5.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor5 {

      def of[HKT[_, _, _, _, _]]: Ctor5[HKT] = macro CrossQuotesMacros.typeCtor5Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)]
        def asUntyped: UntypedType = Ctor5.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor4.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] = new Type.Ctor4.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor4.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] = new Type.Ctor4.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`) => HKT[A, B, C, D, E]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D, E]]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`) => HKT[A, B, C, D, E]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, HKT] = macro CrossQuotesMacros.typeCtor5Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5]]: UpperBounded[U1, U2, U3, U4, U5, HKT] = macro CrossQuotesMacros.typeCtor5Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] = HKT[A, B, C, D, E]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]] = HKT[?, ?, ?, ?, ?]
    }

    final type Ctor6[HKT[_, _, _, _, _, _]] = Ctor6.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor6 {

      def of[HKT[_, _, _, _, _, _]]: Ctor6[HKT] = macro CrossQuotesMacros.typeCtor6Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)]
        def asUntyped: UntypedType = Ctor6.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor5.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor5.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E, F]]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`) => HKT[A, B, C, D, E, F]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, HKT] = macro CrossQuotesMacros.typeCtor6Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6]]: UpperBounded[U1, U2, U3, U4, U5, U6, HKT] = macro CrossQuotesMacros.typeCtor6Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] = HKT[A, B, C, D, E, F]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]] = HKT[?, ?, ?, ?, ?, ?]
    }

    final type Ctor7[HKT[_, _, _, _, _, _, _]] = Ctor7.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor7 {

      def of[HKT[_, _, _, _, _, _, _]]: Ctor7[HKT] = macro CrossQuotesMacros.typeCtor7Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)]
        def asUntyped: UntypedType = Ctor7.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor6.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor6.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F, G]]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`) => HKT[A, B, C, D, E, F, G]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, HKT] = macro CrossQuotesMacros.typeCtor7Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, HKT] = macro CrossQuotesMacros.typeCtor7Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] = HKT[A, B, C, D, E, F, G]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]] = HKT[?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor8[HKT[_, _, _, _, _, _, _, _]] = Ctor8.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor8 {

      def of[HKT[_, _, _, _, _, _, _, _]]: Ctor8[HKT] = macro CrossQuotesMacros.typeCtor8Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)]
        def asUntyped: UntypedType = Ctor8.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor7.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor7.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G, H]]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`) => HKT[A, B, C, D, E, F, G, H]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, HKT] = macro CrossQuotesMacros.typeCtor8Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, HKT] = macro CrossQuotesMacros.typeCtor8Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] = HKT[A, B, C, D, E, F, G, H]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]] = HKT[?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor9[HKT[_, _, _, _, _, _, _, _, _]] = Ctor9.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor9 {

      def of[HKT[_, _, _, _, _, _, _, _, _]]: Ctor9[HKT] = macro CrossQuotesMacros.typeCtor9Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)]
        def asUntyped: UntypedType = Ctor9.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor8.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor8.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H, I]]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`) => HKT[A, B, C, D, E, F, G, H, I]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, HKT] = macro CrossQuotesMacros.typeCtor9Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT] = macro CrossQuotesMacros.typeCtor9Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] = HKT[A, B, C, D, E, F, G, H, I]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor10[HKT[_, _, _, _, _, _, _, _, _, _]] = Ctor10.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor10 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _]]: Ctor10[HKT] = macro CrossQuotesMacros.typeCtor10Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)]
        def asUntyped: UntypedType = Ctor10.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor9.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor9.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I, J]]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`) => HKT[A, B, C, D, E, F, G, H, I, J]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, HKT] = macro CrossQuotesMacros.typeCtor10Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT] = macro CrossQuotesMacros.typeCtor10Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] = HKT[A, B, C, D, E, F, G, H, I, J]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor11[HKT[_, _, _, _, _, _, _, _, _, _, _]] = Ctor11.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor11 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _]]: Ctor11[HKT] = macro CrossQuotesMacros.typeCtor11Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)]
        def asUntyped: UntypedType = Ctor11.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor10.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor10.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`) => HKT[A, B, C, D, E, F, G, H, I, J, K]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, HKT] = macro CrossQuotesMacros.typeCtor11Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT] = macro CrossQuotesMacros.typeCtor11Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] = HKT[A, B, C, D, E, F, G, H, I, J, K]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor12[HKT[_, _, _, _, _, _, _, _, _, _, _, _]] = Ctor12.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor12 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _]]: Ctor12[HKT] = macro CrossQuotesMacros.typeCtor12Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)]
        def asUntyped: UntypedType = Ctor12.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor11.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor11.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, HKT] = macro CrossQuotesMacros.typeCtor12Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT] = macro CrossQuotesMacros.typeCtor12Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] = HKT[A, B, C, D, E, F, G, H, I, J, K, L]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor13[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor13.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor13 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor13[HKT] = macro CrossQuotesMacros.typeCtor13Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)]
        def asUntyped: UntypedType = Ctor13.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor12.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor12.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, HKT] = macro CrossQuotesMacros.typeCtor13Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT] = macro CrossQuotesMacros.typeCtor13Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor14[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor14.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor14 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor14[HKT] = macro CrossQuotesMacros.typeCtor14Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)]
        def asUntyped: UntypedType = Ctor14.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor13.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor13.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, HKT] = macro CrossQuotesMacros.typeCtor14Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT] = macro CrossQuotesMacros.typeCtor14Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor15[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor15.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor15 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor15[HKT] = macro CrossQuotesMacros.typeCtor15Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)]
        def asUntyped: UntypedType = Ctor15.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor14.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor14.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, HKT] = macro CrossQuotesMacros.typeCtor15Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT] = macro CrossQuotesMacros.typeCtor15Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor16[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor16.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor16 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor16[HKT] = macro CrossQuotesMacros.typeCtor16Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)]
        def asUntyped: UntypedType = Ctor16.Bounded.reflectiveAsUntyped(this)

        final def setA[A >: L1 <: U1: Type]: Type.Ctor15.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor15.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, HKT] = macro CrossQuotesMacros.typeCtor16Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT] = macro CrossQuotesMacros.typeCtor16Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor17[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor17.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor17 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor17[HKT] = macro CrossQuotesMacros.typeCtor17Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)]
        def asUntyped: UntypedType = Ctor17.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor16.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor16.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, HKT] = macro CrossQuotesMacros.typeCtor17Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT] = macro CrossQuotesMacros.typeCtor17Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor18[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor18.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor18 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor18[HKT] = macro CrossQuotesMacros.typeCtor18Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)]
        def asUntyped: UntypedType = Ctor18.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor17.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor17.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(16, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(16)), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val rType = Type[R].asInstanceOf[ctx0.WeakTypeTag[R]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(rType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, HKT] = macro CrossQuotesMacros.typeCtor18Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT] = macro CrossQuotesMacros.typeCtor18Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor19[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor19.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor19 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor19[HKT] = macro CrossQuotesMacros.typeCtor19Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)]
        def asUntyped: UntypedType = Ctor19.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor18.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor18.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(16, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(16)), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val rType = Type[R].asInstanceOf[ctx0.WeakTypeTag[R]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(17, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(17)), List(rType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val sType = Type[S].asInstanceOf[ctx0.WeakTypeTag[S]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(sType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, HKT] = macro CrossQuotesMacros.typeCtor19Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT] = macro CrossQuotesMacros.typeCtor19Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor20[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor20.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor20 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor20[HKT] = macro CrossQuotesMacros.typeCtor20Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)]
        def asUntyped: UntypedType = Ctor20.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor19.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor19.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(16, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(16)), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val rType = Type[R].asInstanceOf[ctx0.WeakTypeTag[R]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(17, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(17)), List(rType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val sType = Type[S].asInstanceOf[ctx0.WeakTypeTag[S]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(18, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(18)), List(sType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val tType = Type[T].asInstanceOf[ctx0.WeakTypeTag[T]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(tType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, HKT] = macro CrossQuotesMacros.typeCtor20Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT] = macro CrossQuotesMacros.typeCtor20Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor21[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor21.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor21 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor21[HKT] = macro CrossQuotesMacros.typeCtor21Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20, L21 <:< ? <:< U21` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)]
        def asUntyped: UntypedType = Ctor21.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor20.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor20.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(16, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(16)), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val rType = Type[R].asInstanceOf[ctx0.WeakTypeTag[R]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(17, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(17)), List(rType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val sType = Type[S].asInstanceOf[ctx0.WeakTypeTag[S]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(18, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(18)), List(sType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val tType = Type[T].asInstanceOf[ctx0.WeakTypeTag[T]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(19, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(19)), List(tType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setU[U >: L21 <: U21: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l21.Underlying =:= Type[U] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val uType = Type[U].asInstanceOf[ctx0.WeakTypeTag[U]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(uType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, HKT] = macro CrossQuotesMacros.typeCtor21Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT] = macro CrossQuotesMacros.typeCtor21Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    final type Ctor22[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor22.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor22 {

      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor22[HKT] = macro CrossQuotesMacros.typeCtor22Impl[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20, L21 <:< ? <:< U21, L22 <:< ? <:< U22` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]
        def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)]
        def asUntyped: UntypedType = Ctor22.Bounded.reflectiveAsUntyped(this)
        final def setA[A >: L1 <: U1: Type]: Type.Ctor21.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val aType = Type[A].asInstanceOf[ctx0.WeakTypeTag[A]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.tail,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.head), List(aType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor21.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val bType = Type[B].asInstanceOf[ctx0.WeakTypeTag[B]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(1, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(1)), List(bType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val cType = Type[C].asInstanceOf[ctx0.WeakTypeTag[C]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(2, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(2)), List(cType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val dType = Type[D].asInstanceOf[ctx0.WeakTypeTag[D]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(3, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(3)), List(dType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val eType = Type[E].asInstanceOf[ctx0.WeakTypeTag[E]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(4, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(4)), List(eType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val fType = Type[F].asInstanceOf[ctx0.WeakTypeTag[F]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(5, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(5)), List(fType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val gType = Type[G].asInstanceOf[ctx0.WeakTypeTag[G]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(6, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(6)), List(gType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val hType = Type[H].asInstanceOf[ctx0.WeakTypeTag[H]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(7, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(7)), List(hType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val iType = Type[I].asInstanceOf[ctx0.WeakTypeTag[I]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(8, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(8)), List(iType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val jType = Type[J].asInstanceOf[ctx0.WeakTypeTag[J]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(9, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(9)), List(jType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val kType = Type[K].asInstanceOf[ctx0.WeakTypeTag[K]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(10, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(10)), List(kType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val lType = Type[L].asInstanceOf[ctx0.WeakTypeTag[L]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(11, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(11)), List(lType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val mType = Type[M].asInstanceOf[ctx0.WeakTypeTag[M]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(12, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(12)), List(mType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val nType = Type[N].asInstanceOf[ctx0.WeakTypeTag[N]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(13, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(13)), List(nType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val oType = Type[O].asInstanceOf[ctx0.WeakTypeTag[O]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(14, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(14)), List(oType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val pType = Type[P].asInstanceOf[ctx0.WeakTypeTag[P]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(15, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(15)), List(pType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val qType = Type[Q].asInstanceOf[ctx0.WeakTypeTag[Q]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(16, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(16)), List(qType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val rType = Type[R].asInstanceOf[ctx0.WeakTypeTag[R]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(17, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(17)), List(rType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `T >: L20 <: U20`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val sType = Type[S].asInstanceOf[ctx0.WeakTypeTag[S]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(18, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(18)), List(sType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `U >: L21 <: U21`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l21, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val tType = Type[T].asInstanceOf[ctx0.WeakTypeTag[T]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(19, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(19)), List(tType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setU[U >: L21 <: U21: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L22, U22, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `V >: L22 <: U22`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l21.Underlying =:= Type[U] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l22)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val uType = Type[U].asInstanceOf[ctx0.WeakTypeTag[U]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            val remaining = typeParams.patch(20, Nil, 1)
            internal.polyType(
              remaining,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams(20)), List(uType))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setV[V >: L22 <: U22: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, Lambda[(`A >: L1 <: U1`, `B >: L2 <: U2`, `C >: L3 <: U3`, `D >: L4 <: U4`, `E >: L5 <: U5`, `F >: L6 <: U6`, `G >: L7 <: U7`, `H >: L8 <: U8`, `I >: L9 <: U9`, `J >: L10 <: U10`, `K >: L11 <: U11`, `L >: L12 <: U12`, `M >: L13 <: U13`, `N >: L14 <: U14`, `O >: L15 <: U15`, `P >: L16 <: U16`, `Q >: L17 <: U17`, `R >: L18 <: U18`, `S >: L19 <: U19`, `T >: L20 <: U20`, `U >: L21 <: U21`) => HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l22.Underlying =:= Type[V] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          override def asUntyped: UntypedType = {
            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
            import ctx0.universe._
            val vType = Type[V].asInstanceOf[ctx0.WeakTypeTag[V]].tpe
            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]
            val typeParams = hktType.typeParams
            internal.polyType(
              typeParams.init,
              hktType.typeConstructor.resultType.substituteTypes(List(typeParams.last), List(vType))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {
          val field = bounded.getClass.getDeclaredField("HKT")
          field.setAccessible(true)
          field.get(bounded).asInstanceOf[UntypedType]
        }

        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, HKT] = macro CrossQuotesMacros.typeCtor22Impl[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, HKT]
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21, _ <: U22]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, Nothing, U22, HKT]
      object UpperBounded {

        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21, _ <: U22]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT] = macro CrossQuotesMacros.typeCtor22Impl[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, Nothing, U22, HKT]
      }

      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.
      // But using a type alias and applying values to it finished without c.typecheck errors.
      type Apply[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22], A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] = HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
      type Stub[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]] = HKT[?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]
    }

    /** Returns the `UntypedType` for the identity type constructor `[A] =>> A`. Used by `PlainValue.Result`. */
    private[hearth] lazy val identityCtor1Untyped: UntypedType = {
      val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
      import ctx0.universe._
      val A = ctx0.universe.internal.newFreeType("A")
      internal.polyType(List(A), A.asType.toType).asInstanceOf[UntypedType]
    }
  }
}
