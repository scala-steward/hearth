package hearth
package typed

private[typed] trait TypeConstructors { this: MacroCommons =>

  trait Ctors { this: Type.type =>
    // format: off

    /* Type constructors for some common types.
      
    The code below was not written by hand, but generated by a script. Then updated with AI.
    */

    final type Ctor1[HKT[_]] = Ctor1.Bounded[Nothing, Any, HKT]
    object Ctor1 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_]]: Ctor1[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1` */
      trait Bounded[L1, U1 >: L1, HKT[_ >: L1 <: U1]] {

        def apply[A >: L1 <: U1: Type]: Type[HKT[A]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type[HKT[A]] = apply[A]
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, HKT[_ >: L1 <: U1]]: Bounded[L1, U1, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, HKT[_ >: L1 <: U1]: scala.quoted.Type] extends Bounded[L1, U1, HKT] {
          private lazy val isIArray = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT] =:= quotes.reflect.TypeRepr.of[IArray]
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type]: Type[HKT[A]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            scala.quoted.Type.of[HKT[A]].asInstanceOf[Type[HKT[A]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            if (isIArray) {
              // Workaround since:
              //   case '[IArray[A]] =>
              // is NOT matching the type `IArray[A]`!!!
              import quotes.reflect.*
              TypeRepr.of[A](using A.asInstanceOf[scala.quoted.Type[A]]) match {
                case AppliedType(ctor, List(a)) if ctor =:= TypeRepr.of[IArray] =>
                  Some((a.asType.asInstanceOf[Type[L1]].as_<:??<:[L1, U1]))
                case _ => None
              }
            } else {
              A.asInstanceOf[scala.quoted.Type[A]] match {
                case '[HKT[a]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1]))
                case _ => None
              }
            }
          }
        }
      }

      final type UpperBounded[U1, HKT[_ <: U1]] = Bounded[Nothing, U1, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, HKT[_ <: U1]]: UpperBounded[U1, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor2[HKT[_, _]] = Ctor2.Bounded[Nothing, Any, Nothing, Any, HKT]
    object Ctor2 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _]]: Ctor2[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type]: Type[HKT[A, B]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor1.Bounded[L2, U2, [B >: L2 <: U2] =>> HKT[A, B]] = new Type.Ctor1.Bounded[L2, U2, [B >: L2 <: U2] =>> HKT[A, B]] {
          def apply[B >: L2 <: U2: Type]: Type[HKT[A, B]] = ctor.apply[A, B]
          def unapply[In](In: Type[In]): Option[L2 <:??<: U2] = ctor.unapply(In).collect { case (l1, l2) if l1.Underlying =:= Type[A] => l2 }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor1.Bounded[L1, U1, [A >: L1 <: U1] =>> HKT[A, B]] = new Type.Ctor1.Bounded[L1, U1, [A >: L1 <: U1] =>> HKT[A, B]] {
          def apply[A >: L1 <: U1: Type]: Type[HKT[A, B]] = ctor.apply[A, B]
          def unapply[In](In: Type[In]): Option[L1 <:??<: U1] = ctor.unapply(In).collect { case (l1, l2) if l2.Underlying =:= Type[B] => l1 }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, HKT[_ >: L1 <: U1, _ >: L2 <: U2]]: Bounded[L1, U1, L2, U2, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type]: Type[HKT[A, B]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            scala.quoted.Type.of[HKT[A, B]].asInstanceOf[Type[HKT[A, B]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, HKT[_ <: U1, _ <: U2]] = Bounded[Nothing, U1, Nothing, U2, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, HKT[_ <: U1, _ <: U2]]: UpperBounded[U1, U2, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor3[HKT[_, _, _]] = Ctor3.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor3 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _]]: Ctor3[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]] { ctor =>

        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor2.Bounded[L2, U2, L3, U3, [B >: L2 <: U2, C >: L3 <: U3] =>> HKT[A, B, C]] = new Type.Ctor2.Bounded[L2, U2, L3, U3, [B >: L2 <: U2, C >: L3 <: U3] =>> HKT[A, B, C]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l1.Underlying =:= Type[A] => (l2, l3)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor2.Bounded[L1, U1, L3, U3, [A >: L1 <: U1, C >: L3 <: U3] =>> HKT[A, B, C]] = new Type.Ctor2.Bounded[L1, U1, L3, U3, [A >: L1 <: U1, C >: L3 <: U3] =>> HKT[A, B, C]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l2.Underlying =:= Type[B] => (l1, l3)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor2.Bounded[L1, U1, L2, U2, [A >: L1 <: U1, B >: L2 <: U2] =>> HKT[A, B, C]] = new Type.Ctor2.Bounded[L1, U1, L2, U2, [A >: L1 <: U1, B >: L2 <: U2] =>> HKT[A, B, C]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type]: Type[HKT[A, B, C]] = ctor.apply[A, B, C]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2)] = ctor.unapply(In).collect {
            case (l1, l2, l3) if l3.Underlying =:= Type[C] => (l1, l2)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]]: Bounded[L1, U1, L2, U2, L3, U3, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            scala.quoted.Type.of[HKT[A, B, C]].asInstanceOf[Type[HKT[A, B, C]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, HKT[_ <: U1, _ <: U2, _ <: U3]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, HKT[_ <: U1, _ <: U2, _ <: U3]]: UpperBounded[U1, U2, U3, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor4[HKT[_, _, _, _]] = Ctor4.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor4 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _]]: Ctor4[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor3.Bounded[L2, U2, L3, U3, L4, U4, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D]] = new Type.Ctor3.Bounded[L2, U2, L3, U3, L4, U4, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l1.Underlying =:= Type[A] => (l2, l3, l4)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor3.Bounded[L1, U1, L3, U3, L4, U4, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D]] = new Type.Ctor3.Bounded[L1, U1, L3, U3, L4, U4, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l2.Underlying =:= Type[B] => (l1, l3, l4)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor3.Bounded[L1, U1, L2, U2, L4, U4, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4] =>> HKT[A, B, C, D]] = new Type.Ctor3.Bounded[L1, U1, L2, U2, L4, U4, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4] =>> HKT[A, B, C, D]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l3.Underlying =:= Type[C] => (l1, l2, l4)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor3.Bounded[L1, U1, L2, U2, L3, U3, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3] =>> HKT[A, B, C, D]] = new Type.Ctor3.Bounded[L1, U1, L2, U2, L3, U3, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3] =>> HKT[A, B, C, D]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type]: Type[HKT[A, B, C, D]] = ctor.apply[A, B, C, D]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4) if l4.Underlying =:= Type[D] => (l1, l2, l3)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            scala.quoted.Type.of[HKT[A, B, C, D]].asInstanceOf[Type[HKT[A, B, C, D]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4]]: UpperBounded[U1, U2, U3, U4, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor5[HKT[_, _, _, _, _]] = Ctor5.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor5 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _]]: Ctor5[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor4.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] = new Type.Ctor4.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor4.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] = new Type.Ctor4.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5] =>> HKT[A, B, C, D, E]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D, E]] = new Type.Ctor4.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4] =>> HKT[A, B, C, D, E]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type]: Type[HKT[A, B, C, D, E]] = ctor.apply[A, B, C, D, E]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            scala.quoted.Type.of[HKT[A, B, C, D, E]].asInstanceOf[Type[HKT[A, B, C, D, E]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5]]: UpperBounded[U1, U2, U3, U4, U5, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor6[HKT[_, _, _, _, _, _]] = Ctor6.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor6 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _]]: Ctor6[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor5.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor5.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E, F]] = new Type.Ctor5.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5] =>> HKT[A, B, C, D, E, F]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type]: Type[HKT[A, B, C, D, E, F]] = ctor.apply[A, B, C, D, E, F]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F]].asInstanceOf[Type[HKT[A, B, C, D, E, F]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6]]: UpperBounded[U1, U2, U3, U4, U5, U6, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor7[HKT[_, _, _, _, _, _, _]] = Ctor7.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor7 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _]]: Ctor7[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor6.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor6.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F, G]] = new Type.Ctor6.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6] =>> HKT[A, B, C, D, E, F, G]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type]: Type[HKT[A, B, C, D, E, F, G]] = ctor.apply[A, B, C, D, E, F, G]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor8[HKT[_, _, _, _, _, _, _, _]] = Ctor8.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor8 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _]]: Ctor8[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor7.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor7.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G, H]] = new Type.Ctor7.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7] =>> HKT[A, B, C, D, E, F, G, H]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = ctor.apply[A, B, C, D, E, F, G, H]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor9[HKT[_, _, _, _, _, _, _, _, _]] = Ctor9.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor9 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _]]: Ctor9[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor8.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor8.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H, I]] = new Type.Ctor8.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8] =>> HKT[A, B, C, D, E, F, G, H, I]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = ctor.apply[A, B, C, D, E, F, G, H, I]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor10[HKT[_, _, _, _, _, _, _, _, _, _]] = Ctor10.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor10 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _]]: Ctor10[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor9.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor9.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I, J]] = new Type.Ctor9.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9] =>> HKT[A, B, C, D, E, F, G, H, I, J]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = ctor.apply[A, B, C, D, E, F, G, H, I, J]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor11[HKT[_, _, _, _, _, _, _, _, _, _, _]] = Ctor11.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor11 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _]]: Ctor11[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor10.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor10.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] = new Type.Ctor10.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10] =>> HKT[A, B, C, D, E, F, G, H, I, J, K]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor12[HKT[_, _, _, _, _, _, _, _, _, _, _, _]] = Ctor12.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor12 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _]]: Ctor12[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor11.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor11.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = new Type.Ctor11.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor13[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor13.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor13 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor13[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor12.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor12.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = new Type.Ctor12.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor14[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor14.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor14 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor14[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor13.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor13.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = new Type.Ctor13.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor15[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor15.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor15 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor15[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor14.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor14.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = new Type.Ctor14.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor16[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor16.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor16 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor16[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor15.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor15.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = new Type.Ctor15.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor17[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor17.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor17 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor17[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor16.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor16.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = new Type.Ctor16.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor18[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor18.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor18 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor18[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor17.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor17.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15), tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q], tl.param(16)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = new Type.Ctor17.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), TypeRepr.of[R]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, L18: scala.quoted.Type, U18 >: L18: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17], scala.quoted.Type.of[r].asInstanceOf[Type[r]].as_<:??<:[L18, U18]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor19[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor19.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor19 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor19[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor18.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor18.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15), tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q], tl.param(16), tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), TypeRepr.of[R], tl.param(17)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = new Type.Ctor18.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), TypeRepr.of[S]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, L18: scala.quoted.Type, U18 >: L18: scala.quoted.Type, L19: scala.quoted.Type, U19 >: L19: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17], scala.quoted.Type.of[r].asInstanceOf[Type[r]].as_<:??<:[L18, U18], scala.quoted.Type.of[s].asInstanceOf[Type[s]].as_<:??<:[L19, U19]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor20[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor20.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor20 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor20[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor19.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor19.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15), tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q], tl.param(16), tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), TypeRepr.of[R], tl.param(17), tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), TypeRepr.of[S], tl.param(18)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = new Type.Ctor19.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), TypeRepr.of[T]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, L18: scala.quoted.Type, U18 >: L18: scala.quoted.Type, L19: scala.quoted.Type, U19 >: L19: scala.quoted.Type, L20: scala.quoted.Type, U20 >: L20: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17], scala.quoted.Type.of[r].asInstanceOf[Type[r]].as_<:??<:[L18, U18], scala.quoted.Type.of[s].asInstanceOf[Type[s]].as_<:??<:[L19, U19], scala.quoted.Type.of[t].asInstanceOf[Type[t]].as_<:??<:[L20, U20]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor21[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor21.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor21 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor21[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20, L21 <:< ? <:< U21` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor20.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor20.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q], tl.param(16), tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), TypeRepr.of[R], tl.param(17), tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), TypeRepr.of[S], tl.param(18), tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), TypeRepr.of[T], tl.param(19)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setU[U >: L21 <: U21: Type]: Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = new Type.Ctor20.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21) if l21.Underlying =:= Type[U] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[U] = Type[U].asInstanceOf[scala.quoted.Type[U]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), TypeRepr.of[U]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, L18: scala.quoted.Type, U18 >: L18: scala.quoted.Type, L19: scala.quoted.Type, U19 >: L19: scala.quoted.Type, L20: scala.quoted.Type, U20 >: L20: scala.quoted.Type, L21: scala.quoted.Type, U21 >: L21: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            given scala.quoted.Type[U] = Type[U].asInstanceOf[scala.quoted.Type[U]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17], scala.quoted.Type.of[r].asInstanceOf[Type[r]].as_<:??<:[L18, U18], scala.quoted.Type.of[s].asInstanceOf[Type[s]].as_<:??<:[L19, U19], scala.quoted.Type.of[t].asInstanceOf[Type[t]].as_<:??<:[L20, U20], scala.quoted.Type.of[u].asInstanceOf[Type[u]].as_<:??<:[L21, U21]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    final type Ctor22[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]] = Ctor22.Bounded[Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, Nothing, Any, HKT]
    object Ctor22 {

      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
      def of[HKT[_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]]: Ctor22[HKT] = sys.error("Install cross-quotes-plugin to use this method")

      /** Allow applying and extracting some types `L1 <:< ? <:< U1, L2 <:< ? <:< U2, L3 <:< ? <:< U3, L4 <:< ? <:< U4, L5 <:< ? <:< U5, L6 <:< ? <:< U6, L7 <:< ? <:< U7, L8 <:< ? <:< U8, L9 <:< ? <:< U9, L10 <:< ? <:< U10, L11 <:< ? <:< U11, L12 <:< ? <:< U12, L13 <:< ? <:< U13, L14 <:< ? <:< U14, L15 <:< ? <:< U15, L16 <:< ? <:< U16, L17 <:< ? <:< U17, L18 <:< ? <:< U18, L19 <:< ? <:< U19, L20 <:< ? <:< U20, L21 <:< ? <:< U21, L22 <:< ? <:< U22` */
      trait Bounded[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]] { ctor =>
        
        def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]
        def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)]
        def asUntyped: UntypedType

        final def setA[A >: L1 <: U1: Type]: Type.Ctor21.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l1.Underlying =:= Type[A] => (l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(TypeRepr.of[A], tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setB[B >: L2 <: U2: Type]: Type.Ctor21.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l2.Underlying =:= Type[B] => (l1, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), TypeRepr.of[B], tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setC[C >: L3 <: U3: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l3.Underlying =:= Type[C] => (l1, l2, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), TypeRepr.of[C], tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setD[D >: L4 <: U4: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l4.Underlying =:= Type[D] => (l1, l2, l3, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), TypeRepr.of[D], tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setE[E >: L5 <: U5: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l5.Underlying =:= Type[E] => (l1, l2, l3, l4, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), TypeRepr.of[E], tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setF[F >: L6 <: U6: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l6.Underlying =:= Type[F] => (l1, l2, l3, l4, l5, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), TypeRepr.of[F], tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setG[G >: L7 <: U7: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l7.Underlying =:= Type[G] => (l1, l2, l3, l4, l5, l6, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), TypeRepr.of[G], tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setH[H >: L8 <: U8: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l8.Underlying =:= Type[H] => (l1, l2, l3, l4, l5, l6, l7, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), TypeRepr.of[H], tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setI[I >: L9 <: U9: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l9.Underlying =:= Type[I] => (l1, l2, l3, l4, l5, l6, l7, l8, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), TypeRepr.of[I], tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setJ[J >: L10 <: U10: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l10.Underlying =:= Type[J] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), TypeRepr.of[J], tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setK[K >: L11 <: U11: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l11.Underlying =:= Type[K] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), TypeRepr.of[K], tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setL[L >: L12 <: U12: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l12.Underlying =:= Type[L] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), TypeRepr.of[L], tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setM[M >: L13 <: U13: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l13.Underlying =:= Type[M] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l14, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), TypeRepr.of[M], tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setN[N >: L14 <: U14: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l14.Underlying =:= Type[N] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l15, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), TypeRepr.of[N], tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setO[O >: L15 <: U15: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l15.Underlying =:= Type[O] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l16, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), TypeRepr.of[O], tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setP[P >: L16 <: U16: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l16.Underlying =:= Type[P] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l17, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), TypeRepr.of[P], tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setQ[Q >: L17 <: U17: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l17.Underlying =:= Type[Q] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l18, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), TypeRepr.of[Q], tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setR[R >: L18 <: U18: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L19, U19, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l18.Underlying =:= Type[R] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l19, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), TypeRepr.of[R], tl.param(17), tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setS[S >: L19 <: U19: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L20, U20, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, T >: L20 <: U20, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l19.Underlying =:= Type[S] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l20, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), TypeRepr.of[S], tl.param(18), tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setT[T >: L20 <: U20: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L21, U21, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, U >: L21 <: U21, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L21 <:??<: U21, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l20.Underlying =:= Type[T] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l21, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), TypeRepr.of[T], tl.param(19), tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setU[U >: L21 <: U21: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L22, U22, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, V >: L22 <: U22] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L22 <:??<: U22)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l21.Underlying =:= Type[U] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l22)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[U] = Type[U].asInstanceOf[scala.quoted.Type[U]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), TypeRepr.of[U], tl.param(20)))
            ).asInstanceOf[UntypedType]
          }
        }

        final def setV[V >: L22 <: U22: Type]: Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = new Type.Ctor21.Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, [A >: L1 <: U1, B >: L2 <: U2, C >: L3 <: U3, D >: L4 <: U4, E >: L5 <: U5, F >: L6 <: U6, G >: L7 <: U7, H >: L8 <: U8, I >: L9 <: U9, J >: L10 <: U10, K >: L11 <: U11, L >: L12 <: U12, M >: L13 <: U13, N >: L14 <: U14, O >: L15 <: U15, P >: L16 <: U16, Q >: L17 <: U17, R >: L18 <: U18, S >: L19 <: U19, T >: L20 <: U20, U >: L21 <: U21] =>> HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] {
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = ctor.apply[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]
          def unapply[In](In: Type[In]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21)] = ctor.unapply(In).collect {
            case (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22) if l22.Underlying =:= Type[V] => (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21)
          }
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            import quotes.reflect.*
            given scala.quoted.Type[V] = Type[V].asInstanceOf[scala.quoted.Type[V]]
            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]
            TypeLambda(
              List("_$1", "_$2", "_$3", "_$4", "_$5", "_$6", "_$7", "_$8", "_$9", "_$10", "_$11", "_$12", "_$13", "_$14", "_$15", "_$16", "_$17", "_$18", "_$19", "_$20", "_$21"),
              _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any]), TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
              tl => hktRepr.appliedTo(List(tl.param(0), tl.param(1), tl.param(2), tl.param(3), tl.param(4), tl.param(5), tl.param(6), tl.param(7), tl.param(8), tl.param(9), tl.param(10), tl.param(11), tl.param(12), tl.param(13), tl.param(14), tl.param(15), tl.param(16), tl.param(17), tl.param(18), tl.param(19), tl.param(20), TypeRepr.of[V]))
            ).asInstanceOf[UntypedType]
          }
        }
      }
      object Bounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[L1, U1 >: L1, L2, U2 >: L2, L3, U3 >: L3, L4, U4 >: L4, L5, U5 >: L5, L6, U6 >: L6, L7, U7 >: L7, L8, U8 >: L8, L9, U9 >: L9, L10, U10 >: L10, L11, U11 >: L11, L12, U12 >: L12, L13, U13 >: L13, L14, U14 >: L14, L15, U15 >: L15, L16, U16 >: L16, L17, U17 >: L17, L18, U18 >: L18, L19, U19 >: L19, L20, U20 >: L20, L21, U21 >: L21, L22, U22 >: L22, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]]: Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, HKT] = sys.error("Install cross-quotes-plugin to use this method")

        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least
        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.
        class Impl[L1: scala.quoted.Type, U1 >: L1: scala.quoted.Type, L2: scala.quoted.Type, U2 >: L2: scala.quoted.Type, L3: scala.quoted.Type, U3 >: L3: scala.quoted.Type, L4: scala.quoted.Type, U4 >: L4: scala.quoted.Type, L5: scala.quoted.Type, U5 >: L5: scala.quoted.Type, L6: scala.quoted.Type, U6 >: L6: scala.quoted.Type, L7: scala.quoted.Type, U7 >: L7: scala.quoted.Type, L8: scala.quoted.Type, U8 >: L8: scala.quoted.Type, L9: scala.quoted.Type, U9 >: L9: scala.quoted.Type, L10: scala.quoted.Type, U10 >: L10: scala.quoted.Type, L11: scala.quoted.Type, U11 >: L11: scala.quoted.Type, L12: scala.quoted.Type, U12 >: L12: scala.quoted.Type, L13: scala.quoted.Type, U13 >: L13: scala.quoted.Type, L14: scala.quoted.Type, U14 >: L14: scala.quoted.Type, L15: scala.quoted.Type, U15 >: L15: scala.quoted.Type, L16: scala.quoted.Type, U16 >: L16: scala.quoted.Type, L17: scala.quoted.Type, U17 >: L17: scala.quoted.Type, L18: scala.quoted.Type, U18 >: L18: scala.quoted.Type, L19: scala.quoted.Type, U19 >: L19: scala.quoted.Type, L20: scala.quoted.Type, U20 >: L20: scala.quoted.Type, L21: scala.quoted.Type, U21 >: L21: scala.quoted.Type, L22: scala.quoted.Type, U22 >: L22: scala.quoted.Type, HKT[_ >: L1 <: U1, _ >: L2 <: U2, _ >: L3 <: U3, _ >: L4 <: U4, _ >: L5 <: U5, _ >: L6 <: U6, _ >: L7 <: U7, _ >: L8 <: U8, _ >: L9 <: U9, _ >: L10 <: U10, _ >: L11 <: U11, _ >: L12 <: U12, _ >: L13 <: U13, _ >: L14 <: U14, _ >: L15 <: U15, _ >: L16 <: U16, _ >: L17 <: U17, _ >: L18 <: U18, _ >: L19 <: U19, _ >: L20 <: U20, _ >: L21 <: U21, _ >: L22 <: U22]: scala.quoted.Type] extends Bounded[L1, U1, L2, U2, L3, U3, L4, U4, L5, U5, L6, U6, L7, U7, L8, U8, L9, U9, L10, U10, L11, U11, L12, U12, L13, U13, L14, U14, L15, U15, L16, U16, L17, U17, L18, U18, L19, U19, L20, U20, L21, U21, L22, U22, HKT] {
          def asUntyped: UntypedType = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]
          }
          @scala.annotation.nowarn
          def apply[A >: L1 <: U1: Type, B >: L2 <: U2: Type, C >: L3 <: U3: Type, D >: L4 <: U4: Type, E >: L5 <: U5: Type, F >: L6 <: U6: Type, G >: L7 <: U7: Type, H >: L8 <: U8: Type, I >: L9 <: U9: Type, J >: L10 <: U10: Type, K >: L11 <: U11: Type, L >: L12 <: U12: Type, M >: L13 <: U13: Type, N >: L14 <: U14: Type, O >: L15 <: U15: Type, P >: L16 <: U16: Type, Q >: L17 <: U17: Type, R >: L18 <: U18: Type, S >: L19 <: U19: Type, T >: L20 <: U20: Type, U >: L21 <: U21: Type, V >: L22 <: U22: Type]: Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            given scala.quoted.Type[A] = Type[A].asInstanceOf[scala.quoted.Type[A]]
            given scala.quoted.Type[B] = Type[B].asInstanceOf[scala.quoted.Type[B]]
            given scala.quoted.Type[C] = Type[C].asInstanceOf[scala.quoted.Type[C]]
            given scala.quoted.Type[D] = Type[D].asInstanceOf[scala.quoted.Type[D]]
            given scala.quoted.Type[E] = Type[E].asInstanceOf[scala.quoted.Type[E]]
            given scala.quoted.Type[F] = Type[F].asInstanceOf[scala.quoted.Type[F]]
            given scala.quoted.Type[G] = Type[G].asInstanceOf[scala.quoted.Type[G]]
            given scala.quoted.Type[H] = Type[H].asInstanceOf[scala.quoted.Type[H]]
            given scala.quoted.Type[I] = Type[I].asInstanceOf[scala.quoted.Type[I]]
            given scala.quoted.Type[J] = Type[J].asInstanceOf[scala.quoted.Type[J]]
            given scala.quoted.Type[K] = Type[K].asInstanceOf[scala.quoted.Type[K]]
            given scala.quoted.Type[L] = Type[L].asInstanceOf[scala.quoted.Type[L]]
            given scala.quoted.Type[M] = Type[M].asInstanceOf[scala.quoted.Type[M]]
            given scala.quoted.Type[N] = Type[N].asInstanceOf[scala.quoted.Type[N]]
            given scala.quoted.Type[O] = Type[O].asInstanceOf[scala.quoted.Type[O]]
            given scala.quoted.Type[P] = Type[P].asInstanceOf[scala.quoted.Type[P]]
            given scala.quoted.Type[Q] = Type[Q].asInstanceOf[scala.quoted.Type[Q]]
            given scala.quoted.Type[R] = Type[R].asInstanceOf[scala.quoted.Type[R]]
            given scala.quoted.Type[S] = Type[S].asInstanceOf[scala.quoted.Type[S]]
            given scala.quoted.Type[T] = Type[T].asInstanceOf[scala.quoted.Type[T]]
            given scala.quoted.Type[U] = Type[U].asInstanceOf[scala.quoted.Type[U]]
            given scala.quoted.Type[V] = Type[V].asInstanceOf[scala.quoted.Type[V]]
            scala.quoted.Type.of[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]].asInstanceOf[Type[HKT[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]]]
          }
          def unapply[A](A: Type[A]): Option[(L1 <:??<: U1, L2 <:??<: U2, L3 <:??<: U3, L4 <:??<: U4, L5 <:??<: U5, L6 <:??<: U6, L7 <:??<: U7, L8 <:??<: U8, L9 <:??<: U9, L10 <:??<: U10, L11 <:??<: U11, L12 <:??<: U12, L13 <:??<: U13, L14 <:??<: U14, L15 <:??<: U15, L16 <:??<: U16, L17 <:??<: U17, L18 <:??<: U18, L19 <:??<: U19, L20 <:??<: U20, L21 <:??<: U21, L22 <:??<: U22)] = {
            given quotes: scala.quoted.Quotes = CrossQuotes.ctx
            A.asInstanceOf[scala.quoted.Type[A]] match {
              case '[HKT[a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1], scala.quoted.Type.of[b].asInstanceOf[Type[b]].as_<:??<:[L2, U2], scala.quoted.Type.of[c].asInstanceOf[Type[c]].as_<:??<:[L3, U3], scala.quoted.Type.of[d].asInstanceOf[Type[d]].as_<:??<:[L4, U4], scala.quoted.Type.of[e].asInstanceOf[Type[e]].as_<:??<:[L5, U5], scala.quoted.Type.of[f].asInstanceOf[Type[f]].as_<:??<:[L6, U6], scala.quoted.Type.of[g].asInstanceOf[Type[g]].as_<:??<:[L7, U7], scala.quoted.Type.of[h].asInstanceOf[Type[h]].as_<:??<:[L8, U8], scala.quoted.Type.of[i].asInstanceOf[Type[i]].as_<:??<:[L9, U9], scala.quoted.Type.of[j].asInstanceOf[Type[j]].as_<:??<:[L10, U10], scala.quoted.Type.of[k].asInstanceOf[Type[k]].as_<:??<:[L11, U11], scala.quoted.Type.of[l].asInstanceOf[Type[l]].as_<:??<:[L12, U12], scala.quoted.Type.of[m].asInstanceOf[Type[m]].as_<:??<:[L13, U13], scala.quoted.Type.of[n].asInstanceOf[Type[n]].as_<:??<:[L14, U14], scala.quoted.Type.of[o].asInstanceOf[Type[o]].as_<:??<:[L15, U15], scala.quoted.Type.of[p].asInstanceOf[Type[p]].as_<:??<:[L16, U16], scala.quoted.Type.of[q].asInstanceOf[Type[q]].as_<:??<:[L17, U17], scala.quoted.Type.of[r].asInstanceOf[Type[r]].as_<:??<:[L18, U18], scala.quoted.Type.of[s].asInstanceOf[Type[s]].as_<:??<:[L19, U19], scala.quoted.Type.of[t].asInstanceOf[Type[t]].as_<:??<:[L20, U20], scala.quoted.Type.of[u].asInstanceOf[Type[u]].as_<:??<:[L21, U21], scala.quoted.Type.of[v].asInstanceOf[Type[v]].as_<:??<:[L22, U22]))
              case _ => None
            }
          }
        }
      }

      final type UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21, _ <: U22]] = Bounded[Nothing, U1, Nothing, U2, Nothing, U3, Nothing, U4, Nothing, U5, Nothing, U6, Nothing, U7, Nothing, U8, Nothing, U9, Nothing, U10, Nothing, U11, Nothing, U12, Nothing, U13, Nothing, U14, Nothing, U15, Nothing, U16, Nothing, U17, Nothing, U18, Nothing, U19, Nothing, U20, Nothing, U21, Nothing, U22, HKT]
      object UpperBounded {

        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")
        def of[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT[_ <: U1, _ <: U2, _ <: U3, _ <: U4, _ <: U5, _ <: U6, _ <: U7, _ <: U8, _ <: U9, _ <: U10, _ <: U11, _ <: U12, _ <: U13, _ <: U14, _ <: U15, _ <: U16, _ <: U17, _ <: U18, _ <: U19, _ <: U20, _ <: U21, _ <: U22]]: UpperBounded[U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, HKT] = sys.error("Install cross-quotes-plugin to use this method")
      }
    }

    /** Returns the `UntypedType` for the identity type constructor `[A] =>> A`. Used by `PlainValue.Result`. */
    private[hearth] lazy val identityCtor1Untyped: UntypedType = {
      given quotes: scala.quoted.Quotes = CrossQuotes.ctx
      import quotes.reflect.*
      TypeLambda(
        List("A"),
        _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
        tl => tl.param(0)
      ).asInstanceOf[UntypedType]
    }
  }
}
