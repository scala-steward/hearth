/** Generates the TypeConstructors.scala source for both Scala 2 and Scala 3.
  *
  * Uses [[ArityGen]] for shared naming helpers (paramName, lower, upper, etc.).
  */
object TypeConstructorsGen {

  // ---------------------------------------------------------------------------
  // Shared helpers
  // ---------------------------------------------------------------------------

  private val p = ArityGen.paramName _
  private val dq = '"'

  /** Lowercase version of param name at position i (0-based): a, b, c, ... */
  private def lp(i: Int): String = p(i).toLowerCase

  /** "L1 <:??<: U1" */
  private def bound(i: Int): String = s"${ArityGen.lower(i)} <:??<: ${ArityGen.upper(i)}"

  /** "(L1 <:??<: U1, L2 <:??<: U2, ...)" — always with parens (for Bounded trait abstract unapply) */
  private def boundsTuple(n: Int): String =
    (1 to n).map(bound).mkString("(", ", ", ")")

  /** For set* methods returning Ctor1: no tuple parens. For Ctor2+: with tuple parens. */
  private def boundsOptionType(indices: Seq[Int]): String =
    if (indices.size == 1) bound(indices.head)
    else indices.map(bound).mkString("(", ", ", ")")

  /** "l1, l2, l3, ..." — lowercase bound var names */
  private def lVars(n: Int): String = (1 to n).map(i => s"l$i").mkString(", ")

  /** Remaining indices (1-based) after removing pos (0-based) */
  private def remainingIndices(n: Int, pos: Int): Seq[Int] =
    (0 until n).filter(_ != pos).map(_ + 1)

  /** Remaining param names after removing pos (0-based) */
  private def remainingParams(n: Int, pos: Int): Seq[String] =
    (0 until n).filter(_ != pos).map(p)

  /** Remaining bounds pairs for set method type signature */
  private def remainingBoundsPairs(n: Int, pos: Int): String =
    remainingIndices(n, pos).map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)} >: ${ArityGen.lower(i)}").mkString(", ")

  /** Remaining HKT slots for set method type signature */
  private def remainingHktSlots(n: Int, pos: Int): String =
    remainingIndices(n, pos).map(i => s"_ >: ${ArityGen.lower(i)} <: ${ArityGen.upper(i)}").mkString(", ")

  /** All param names for a given arity: "A, B, C" */
  private def allParams(n: Int): String = ArityGen.paramNameList(n)

  /** Bounds description for scaladoc: "L1 <:< ? <:< U1, L2 <:< ? <:< U2, ..." */
  private def boundsDoc(n: Int): String =
    (1 to n).map(i => s"${ArityGen.lower(i)} <:< ? <:< ${ArityGen.upper(i)}").mkString(", ")

  // ---------------------------------------------------------------------------
  // Scala 3
  // ---------------------------------------------------------------------------

  def scala3(maxArity: Int = 22): String = {
    val sb = new StringBuilder
    sb ++= header3
    for (n <- 1 to maxArity) sb ++= ctorBlock3(n)
    sb ++= footer3
    sb.toString
  }

  private val header3: String =
    s"""|package hearth
        |package typed
        |
        |// $$COVERAGE-OFF$$
        |private[typed] trait TypeConstructors { this: MacroCommons =>
        |
        |  trait Ctors { this: Type.type =>
        |    // format: off
        |
        |    /* Type constructors for some common types.
        |      
        |    The code below was not written by hand, but generated by a script. Then updated with AI.
        |    */
        |
        |""".stripMargin

  private val footer3: String =
    s"""|    /** Returns the `UntypedType` for the identity type constructor `[A] =>> A`. Used by `PlainValue.Result`. */
        |    private[hearth] lazy val identityCtor1Untyped: UntypedType = {
        |      given quotes: scala.quoted.Quotes = CrossQuotes.ctx
        |      import quotes.reflect.*
        |      TypeLambda(
        |        List("A"),
        |        _ => List(TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])),
        |        tl => tl.param(0)
        |      ).asInstanceOf[UntypedType]
        |    }
        |  }
        |}
        |""".stripMargin

  private def ctorBlock3(n: Int): String = {
    val cn = ArityGen.ctorName(n)
    val sb = new StringBuilder

    // Type alias
    sb ++= s"    final type $cn[HKT[${ArityGen.simpleHktSlots(n)}]] = $cn.Bounded[${ArityGen.nothingAnyPairs(n)}, HKT]\n"
    sb ++= s"    object $cn {\n"
    sb ++= s"\n"

    // of method
    sb ++= s"""      @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"""      def of[HKT[${ArityGen.simpleHktSlots(n)}]]: $cn[HKT] = sys.error("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"\n"

    // fromUntyped method
    sb ++= s"      def fromUntyped[HKT[${ArityGen.simpleHktSlots(n)}]](untyped: UntypedType): $cn[HKT] = new Bounded.FromUntypedImpl[${ArityGen.nothingAnyPairs(n)}, HKT](untyped)\n"
    sb ++= s"\n"

    // Bounded trait
    sb ++= s"      /** Allow applying and extracting some types `${boundsDoc(n)}` */\n"
    if (n == 1) {
      sb ++= s"      trait Bounded[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]] {\n"
    } else {
      sb ++= s"      trait Bounded[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]] { ctor =>\n"
    }
    sb ++= s"\n"
    sb ++= s"        def apply[${ArityGen.applyParams(n)}]: Type[HKT[${allParams(n)}]]\n"
    sb ++= s"        def unapply[A](A: Type[A]): Option[${boundsTuple(n)}]\n"
    sb ++= s"        def asUntyped: UntypedType\n"

    // set methods
    for (pos <- 0 until n) {
      sb ++= s"\n"
      sb ++= setMethod3(n, pos)
    }

    sb ++= s"      }\n"

    // Bounded companion object
    sb ++= s"      object Bounded {\n"
    sb ++= s"\n"
    sb ++= s"""        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"""        def of[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]]: Bounded[${boundsAndHkt(n)}] = sys.error("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"\n"

    // FromUntypedImpl
    sb ++= fromUntypedImpl3(n)
    sb ++= s"\n"

    // Impl
    sb ++= impl3(n)

    sb ++= s"      }\n"
    sb ++= s"\n"

    // UpperBounded
    sb ++= upperBounded3(n)
    sb ++= s"    }\n"
    sb ++= s"\n"

    sb.toString
  }

  /** "L1, U1, L2, U2, ..., HKT" */
  private def boundsAndHkt(n: Int): String = {
    val pairs = (1 to n).map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)}").mkString(", ")
    s"$pairs, HKT"
  }

  private def setMethod3(n: Int, pos: Int): String = {
    val fixedParam = p(pos)
    val fixedIdx = pos + 1 // 1-based
    val remaining = remainingIndices(n, pos)
    val remainingParamNames = remainingParams(n, pos)

    if (n == 1) {
      // Ctor1: setA simply returns apply[A]
      s"        final def set$fixedParam[$fixedParam >: ${ArityGen.lower(fixedIdx)} <: ${ArityGen.upper(fixedIdx)}: Type]: Type[HKT[$fixedParam]] = apply[$fixedParam]\n"
    } else {
      val m = n - 1 // result arity
      val resultCtor = ArityGen.ctorName(m)
      val resultBounds = remaining.map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)}").mkString(", ")

      // Type lambda: [B >: L2 <: U2, C >: L3 <: U3] =>> HKT[A, B, C]
      val lambdaParams = remaining.zip(remainingParamNames).map { case (i, name) =>
        s"$name >: ${ArityGen.lower(i)} <: ${ArityGen.upper(i)}"
      }.mkString(", ")
      val lambdaBody = allParams(n)
      val typeLambda = s"[$lambdaParams] =>> HKT[$lambdaBody]"

      val fullType = s"Type.$resultCtor.Bounded[$resultBounds, $typeLambda]"

      // apply params (only remaining)
      val applyPs = remaining.zip(remainingParamNames).map { case (i, name) =>
        s"$name >: ${ArityGen.lower(i)} <: ${ArityGen.upper(i)}: Type"
      }.mkString(", ")

      // unapply
      val unapplyReturn = boundsOptionType(remaining)
      val allLVars = lVars(n)
      val keptLVars = remaining.map(i => s"l$i")
      val checkVar = s"l$fixedIdx"

      val unapplyBody = if (m == 1) {
        // Single remaining: single-line collect
        s"ctor.unapply(In).collect { case ($allLVars) if $checkVar.Underlying =:= Type[$fixedParam] => ${keptLVars.mkString(", ")} }"
      } else {
        // Multi remaining: multi-line collect
        s"ctor.unapply(In).collect {\n            case ($allLVars) if $checkVar.Underlying =:= Type[$fixedParam] => (${keptLVars.mkString(", ")})\n          }"
      }

      // asUntyped body
      val numRemaining = m
      val tlParamNames = (0 until numRemaining).map(i => s""""_$$${i + 1}"""").mkString(", ")
      val tlBounds = Seq.fill(numRemaining)("TypeBounds(TypeRepr.of[Nothing], TypeRepr.of[Any])").mkString(", ")

      // Build appliedTo list: for the fixed param use TypeRepr.of[X], for others use tl.param(idx)
      val appliedToArgs = {
        var tlIdx = 0
        (0 until n).map { i =>
          if (i == pos) {
            s"TypeRepr.of[$fixedParam]"
          } else {
            val r = s"tl.param($tlIdx)"
            tlIdx += 1
            r
          }
        }.mkString(", ")
      }

      val sb = new StringBuilder
      sb ++= s"        final def set$fixedParam[$fixedParam >: ${ArityGen.lower(fixedIdx)} <: ${ArityGen.upper(fixedIdx)}: Type]: $fullType = new $fullType {\n"
      sb ++= s"          def apply[$applyPs]: Type[HKT[${allParams(n)}]] = ctor.apply[${allParams(n)}]\n"
      sb ++= s"          def unapply[In](In: Type[In]): Option[$unapplyReturn] = $unapplyBody\n"
      sb ++= s"          def asUntyped: UntypedType = {\n"
      sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
      sb ++= s"            import quotes.reflect.*\n"
      sb ++= s"            given scala.quoted.Type[$fixedParam] = Type[$fixedParam].asInstanceOf[scala.quoted.Type[$fixedParam]]\n"
      sb ++= s"            val hktRepr = ctor.asUntyped.asInstanceOf[TypeRepr]\n"
      sb ++= s"            TypeLambda(\n"
      sb ++= s"              List($tlParamNames),\n"
      sb ++= s"              _ => List($tlBounds),\n"
      sb ++= s"              tl => hktRepr.appliedTo(List($appliedToArgs))\n"
      sb ++= s"            ).asInstanceOf[UntypedType]\n"
      sb ++= s"          }\n"
      sb ++= s"        }\n"

      sb.toString
    }
  }

  private def fromUntypedImpl3(n: Int): String = {
    val sb = new StringBuilder
    sb ++= s"        class FromUntypedImpl[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]](hktRepr: UntypedType) extends Bounded[${boundsAndHkt(n)}] {\n"
    sb ++= s"          def asUntyped: UntypedType = hktRepr\n"

    // apply
    sb ++= s"          def apply[${ArityGen.applyParams(n)}]: Type[HKT[${allParams(n)}]] = {\n"
    sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
    sb ++= s"            import quotes.reflect.*\n"
    for (i <- 0 until n) {
      val name = p(i)
      sb ++= s"            val ${lp(i)}Repr = TypeRepr.of[$name](using Type[$name].asInstanceOf[scala.quoted.Type[$name]])\n"
    }
    val reprList = (0 until n).map(i => s"${lp(i)}Repr").mkString(", ")
    sb ++= s"            hktRepr.asInstanceOf[TypeRepr].appliedTo(List($reprList)).asType.asInstanceOf[Type[HKT[${allParams(n)}]]]\n"
    sb ++= s"          }\n"

    // unapply
    sb ++= s"          def unapply[A](A: Type[A]): Option[${boundsTuple(n)}] = {\n"
    sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
    sb ++= s"            import quotes.reflect.*\n"
    sb ++= s"            val aRepr = TypeRepr.of[A](using A.asInstanceOf[scala.quoted.Type[A]])\n"
    val matchVars = (0 until n).map(lp).mkString(", ")
    val someArgs = (0 until n).map { i =>
      val idx = i + 1
      s"${lp(i)}.asType.asInstanceOf[Type[${ArityGen.lower(idx)}]].as_<:??<:[${ArityGen.lower(idx)}, ${ArityGen.upper(idx)}]"
    }.mkString(", ")
    sb ++= s"            aRepr match {\n"
    sb ++= s"              case AppliedType(ctor, List($matchVars)) if ctor =:= hktRepr.asInstanceOf[TypeRepr] =>\n"
    val someWrapped = if (n == 1) s"Some($someArgs)" else s"Some(($someArgs))"
    sb ++= s"                $someWrapped\n"
    sb ++= s"              case _ =>\n"
    sb ++= s"                aRepr.baseType(hktRepr.asInstanceOf[TypeRepr].typeSymbol) match {\n"
    sb ++= s"                  case AppliedType(_, List($matchVars)) =>\n"
    sb ++= s"                    $someWrapped\n"
    sb ++= s"                  case _ => None\n"
    sb ++= s"                }\n"
    sb ++= s"            }\n"
    sb ++= s"          }\n"
    sb ++= s"        }\n"

    sb.toString
  }

  private def impl3(n: Int): String = {
    val sb = new StringBuilder

    // Class header
    sb ++= s"        // We cannot use a macro here, we have to use compiler plugin, but at least, we at least\n"
    sb ++= s"        // we can extract the body, so that only the `scala.quotes.Type` would be generated by the plugin.\n"

    val implParams = (1 to n).flatMap { i =>
      Seq(s"${ArityGen.lower(i)}: scala.quoted.Type", s"${ArityGen.upper(i)} >: ${ArityGen.lower(i)}: scala.quoted.Type")
    }.mkString(", ")
    sb ++= s"        class Impl[$implParams, HKT[${ArityGen.hktSlots(n)}]: scala.quoted.Type] extends Bounded[${boundsAndHkt(n)}] {\n"

    if (n == 1) {
      // isIArray field (Ctor1 only)
      sb ++= s"          private lazy val isIArray = {\n"
      sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
      sb ++= s"            quotes.reflect.TypeRepr.of[HKT] =:= quotes.reflect.TypeRepr.of[IArray]\n"
      sb ++= s"          }\n"
    }

    // asUntyped
    sb ++= s"          def asUntyped: UntypedType = {\n"
    sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
    sb ++= s"            quotes.reflect.TypeRepr.of[HKT].asInstanceOf[UntypedType]\n"
    sb ++= s"          }\n"

    // apply
    sb ++= s"          @scala.annotation.nowarn\n"
    sb ++= s"          def apply[${ArityGen.applyParams(n)}]: Type[HKT[${allParams(n)}]] = {\n"
    sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"
    for (i <- 0 until n) {
      val name = p(i)
      sb ++= s"            given scala.quoted.Type[$name] = Type[$name].asInstanceOf[scala.quoted.Type[$name]]\n"
    }
    sb ++= s"            scala.quoted.Type.of[HKT[${allParams(n)}]].asInstanceOf[Type[HKT[${allParams(n)}]]]\n"
    sb ++= s"          }\n"

    // unapply
    sb ++= s"          def unapply[A](A: Type[A]): Option[${boundsTuple(n)}] = {\n"
    sb ++= s"            given quotes: scala.quoted.Quotes = CrossQuotes.ctx\n"

    if (n == 1) {
      // Ctor1: IArray workaround
      sb ++= s"            if (isIArray) {\n"
      sb ++= s"              // Workaround since:\n"
      sb ++= s"              //   case '[IArray[A]] =>\n"
      sb ++= s"              // is NOT matching the type `IArray[A]`!!!\n"
      sb ++= s"              import quotes.reflect.*\n"
      sb ++= s"              TypeRepr.of[A](using A.asInstanceOf[scala.quoted.Type[A]]) match {\n"
      sb ++= s"                case AppliedType(ctor, List(a)) if ctor =:= TypeRepr.of[IArray] =>\n"
      sb ++= s"                  Some((a.asType.asInstanceOf[Type[L1]].as_<:??<:[L1, U1]))\n"
      sb ++= s"                case _ => None\n"
      sb ++= s"              }\n"
      sb ++= s"            } else {\n"
      sb ++= s"              A.asInstanceOf[scala.quoted.Type[A]] match {\n"
      sb ++= s"                case '[HKT[a]] => Some((scala.quoted.Type.of[a].asInstanceOf[Type[a]].as_<:??<:[L1, U1]))\n"
      sb ++= s"                case _ => None\n"
      sb ++= s"              }\n"
      sb ++= s"            }\n"
    } else {
      // Ctor2+: simple pattern match
      val matchVars = (0 until n).map(lp).mkString(", ")
      val someArgs = (0 until n).map { i =>
        val idx = i + 1
        s"scala.quoted.Type.of[${lp(i)}].asInstanceOf[Type[${lp(i)}]].as_<:??<:[${ArityGen.lower(idx)}, ${ArityGen.upper(idx)}]"
      }.mkString(", ")
      sb ++= s"            A.asInstanceOf[scala.quoted.Type[A]] match {\n"
      sb ++= s"              case '[HKT[$matchVars]] => Some(($someArgs))\n"
      sb ++= s"              case _ => None\n"
      sb ++= s"            }\n"
    }

    sb ++= s"          }\n"
    sb ++= s"        }\n"

    sb.toString
  }

  private def upperBounded3(n: Int): String = {
    val sb = new StringBuilder
    val ubParams = ArityGen.upperBoundedParams(n)
    val ubHkt = ArityGen.upperBoundedHktSlots(n)
    val ubAlias = ArityGen.nothingUpperPairs(n)

    sb ++= s"      final type UpperBounded[$ubParams, HKT[$ubHkt]] = Bounded[$ubAlias, HKT]\n"
    sb ++= s"      object UpperBounded {\n"
    sb ++= s"\n"
    sb ++= s"""        @scala.annotation.compileTimeOnly("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"""        def of[$ubParams, HKT[$ubHkt]]: UpperBounded[$ubParams, HKT] = sys.error("Install cross-quotes-plugin to use this method")\n"""
    sb ++= s"      }\n"

    sb.toString
  }

  // ---------------------------------------------------------------------------
  // Scala 2
  // ---------------------------------------------------------------------------

  def scala2(maxArity: Int = 22): String = {
    val sb = new StringBuilder
    sb ++= header2
    for (n <- 1 to maxArity) sb ++= ctorBlock2(n)
    sb ++= footer2
    sb.toString
  }

  private val header2: String =
    s"""|package hearth
        |package typed
        |
        |// $$COVERAGE-OFF$$
        |import hearth.cq.CrossQuotesMacros
        |import scala.language.experimental.macros
        |
        |private[typed] trait TypeConstructors { this: MacroCommons =>
        |
        |  trait Ctors { this: Type.type =>
        |    // format: off
        |
        |    /* Type constructors for some common types.
        |      
        |    The code below was not written by hand, but generated by a script. Then updated with AI.
        |    */
        |
        |""".stripMargin

  private val footer2: String =
    s"""|    /** Returns the `UntypedType` for the identity type constructor `[A] =>> A`. Used by `PlainValue.Result`. */
        |    private[hearth] lazy val identityCtor1Untyped: UntypedType = {
        |      val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]
        |      import ctx0.universe._
        |      val A = ctx0.universe.internal.newFreeType("A")
        |      internal.polyType(List(A), A.asType.toType).asInstanceOf[UntypedType]
        |    }
        |  }
        |}
        |""".stripMargin

  private def ctorBlock2(n: Int): String = {
    val cn = ArityGen.ctorName(n)
    val sb = new StringBuilder

    // Type alias
    sb ++= s"    final type $cn[HKT[${ArityGen.simpleHktSlots(n)}]] = $cn.Bounded[${ArityGen.nothingAnyPairs(n)}, HKT]\n"
    sb ++= s"    object $cn {\n"
    sb ++= s"\n"

    // of method (macro)
    sb ++= s"      def of[HKT[${ArityGen.simpleHktSlots(n)}]]: $cn[HKT] = macro CrossQuotesMacros.typeCtor${n}Impl[${ArityGen.nothingAnyPairs(n)}, HKT]\n"
    sb ++= s"\n"

    // fromUntyped method (macro)
    sb ++= s"      def fromUntyped[HKT[${ArityGen.simpleHktSlots(n)}]](untyped: UntypedType): $cn[HKT] = macro CrossQuotesMacros.typeCtor${n}FromUntypedImpl[${ArityGen.nothingAnyPairs(n)}, HKT]\n"
    sb ++= s"\n"

    // Bounded trait
    sb ++= s"      /** Allow applying and extracting some types `${boundsDoc(n)}` */\n"
    if (n == 1) {
      sb ++= s"      trait Bounded[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]] {\n"
    } else {
      sb ++= s"      trait Bounded[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]] { ctor =>\n"
    }
    sb ++= s"\n"
    sb ++= s"        def apply[${ArityGen.applyParams(n)}]: Type[HKT[${allParams(n)}]]\n"
    sb ++= s"        def unapply[In](In: Type[In]): Option[${boundsTuple(n)}]\n"

    if (n == 1) {
      sb ++= s"        /** Returns the underlying untyped type constructor representation. */\n"
    }
    sb ++= s"        def asUntyped: UntypedType = $cn.Bounded.reflectiveAsUntyped(this)\n"

    // set methods
    for (pos <- 0 until n) {
      sb ++= s"\n"
      sb ++= setMethod2(n, pos)
    }

    sb ++= s"      }\n"

    // Bounded companion object
    sb ++= s"      object Bounded {\n"
    if (n >= 4) {
      sb ++= s"\n"
    }

    if (n == 1) {
      sb ++= s"        /** Reflectively reads the private `HKT` field from macro-generated anonymous Bounded classes.\n"
      sb ++= s"          * This is necessary because Scala 2 macro-generated quasiquotes cannot reference the `UntypedType`\n"
      sb ++= s"          * type alias, so the `asUntyped` method cannot be overridden in the generated code.\n"
      sb ++= s"          */\n"
    }
    sb ++= s"        private[Ctors] def reflectiveAsUntyped(bounded: AnyRef): UntypedType = {\n"
    sb ++= s"          val field = bounded.getClass.getDeclaredField(${dq}HKT${dq})\n"
    sb ++= s"          field.setAccessible(true)\n"
    sb ++= s"          field.get(bounded).asInstanceOf[UntypedType]\n"
    sb ++= s"        }\n"
    sb ++= s"\n"

    // Bounded.of (macro)
    sb ++= s"        def of[${ArityGen.boundsPairs(n)}, HKT[${ArityGen.hktSlots(n)}]]: Bounded[${boundsAndHkt(n)}] = macro CrossQuotesMacros.typeCtor${n}Impl[${allBoundsExplicit(n)}, HKT]\n"
    sb ++= s"      }\n"
    sb ++= s"\n"

    // UpperBounded
    sb ++= upperBounded2(n)

    // Apply & Stub type aliases
    sb ++= s"\n"
    sb ++= s"      // Used inside the macro, because apparently applying TypeName or existential type to HKT[_] is not possible.\n"
    sb ++= s"      // But using a type alias and applying values to it finished without c.typecheck errors.\n"
    sb ++= applyType2(n)
    sb ++= stubType2(n)
    sb ++= s"    }\n"
    sb ++= s"\n"

    sb.toString
  }

  /** "L1, U1, L2, U2, ..." (explicit, not with >: constraints) */
  private def allBoundsExplicit(n: Int): String =
    (1 to n).map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)}").mkString(", ")

  private def setMethod2(n: Int, pos: Int): String = {
    val fixedParam = p(pos)
    val fixedIdx = pos + 1
    val remaining = remainingIndices(n, pos)
    val remainingParamNames = remainingParams(n, pos)

    if (n == 1) {
      // Ctor1: setA simply returns apply[A]
      s"        final def set$fixedParam[$fixedParam >: ${ArityGen.lower(fixedIdx)} <: ${ArityGen.upper(fixedIdx)}: Type]: Type[HKT[$fixedParam]] = apply[$fixedParam]\n"
    } else {
      val m = n - 1
      val resultCtor = ArityGen.ctorName(m)
      val resultBounds = remaining.map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)}").mkString(", ")

      // Lambda syntax for Scala 2 (kind-projector)
      val lambdaParams = remaining.zip(remainingParamNames).map { case (i, name) =>
        s"`$name >: ${ArityGen.lower(i)} <: ${ArityGen.upper(i)}`"
      }
      val lambdaParamList = if (m == 1) lambdaParams.head else lambdaParams.mkString("(", ", ", ")")
      val typeLambda = s"Lambda[$lambdaParamList => HKT[${allParams(n)}]]"

      val fullType = s"Type.$resultCtor.Bounded[$resultBounds, $typeLambda]"

      // apply params (only remaining)
      val applyPs = remaining.zip(remainingParamNames).map { case (i, name) =>
        s"$name >: ${ArityGen.lower(i)} <: ${ArityGen.upper(i)}: Type"
      }.mkString(", ")

      // unapply
      val unapplyReturn = boundsOptionType(remaining)
      val allLVars = lVars(n)
      val keptLVars = remaining.map(i => s"l$i")
      val checkVar = s"l$fixedIdx"

      val unapplyBody = if (m == 1) {
        s"ctor.unapply(In).collect {\n            case ($allLVars) if $checkVar.Underlying =:= Type[$fixedParam] => ${keptLVars.mkString(", ")}\n          }"
      } else {
        s"ctor.unapply(In).collect {\n            case ($allLVars) if $checkVar.Underlying =:= Type[$fixedParam] => (${keptLVars.mkString(", ")})\n          }"
      }

      // asUntyped body (Scala 2 reflection)
      val fixedParamLower = fixedParam.toLowerCase
      val remainingExpr = if (pos == 0) "typeParams.tail"
        else if (pos == n - 1) "typeParams.init"
        else s"typeParams.patch($pos, Nil, 1)"
      val substituteExpr = if (pos == 0) "List(typeParams.head)"
        else if (pos == n - 1) "List(typeParams.last)"
        else s"List(typeParams($pos))"

      val sb = new StringBuilder
      sb ++= s"        final def set$fixedParam[$fixedParam >: ${ArityGen.lower(fixedIdx)} <: ${ArityGen.upper(fixedIdx)}: Type]: $fullType = new $fullType {\n"
      sb ++= s"          def apply[$applyPs]: Type[HKT[${allParams(n)}]] = ctor.apply[${allParams(n)}]\n"
      sb ++= s"          def unapply[In](In: Type[In]): Option[$unapplyReturn] = $unapplyBody\n"
      sb ++= s"          override def asUntyped: UntypedType = {\n"
      sb ++= s"            val ctx0 = CrossQuotes.ctx[scala.reflect.macros.blackbox.Context]\n"
      sb ++= s"            import ctx0.universe._\n"
      sb ++= s"            val ${fixedParamLower}Type = Type[$fixedParam].asInstanceOf[ctx0.WeakTypeTag[$fixedParam]].tpe\n"
      sb ++= s"            val hktType = ctor.asUntyped.asInstanceOf[ctx0.Type]\n"
      sb ++= s"            val typeParams = hktType.typeParams\n"
      if (pos != 0 && pos != n - 1) {
        sb ++= s"            val remaining = $remainingExpr\n"
        sb ++= s"            internal.polyType(\n"
        sb ++= s"              remaining,\n"
      } else {
        sb ++= s"            internal.polyType(\n"
        sb ++= s"              $remainingExpr,\n"
      }
      sb ++= s"              hktType.typeConstructor.resultType.substituteTypes($substituteExpr, List(${fixedParamLower}Type))\n"
      sb ++= s"            ).asInstanceOf[UntypedType]\n"
      sb ++= s"          }\n"
      sb ++= s"        }\n"

      sb.toString
    }
  }

  private def upperBounded2(n: Int): String = {
    val sb = new StringBuilder
    val ubParams = ArityGen.upperBoundedParams(n)
    val ubHkt = ArityGen.upperBoundedHktSlots(n)
    val ubAlias = ArityGen.nothingUpperPairs(n)
    val macroNothingUpper = (1 to n).map(i => s"Nothing, ${ArityGen.upper(i)}").mkString(", ")

    sb ++= s"      final type UpperBounded[$ubParams, HKT[$ubHkt]] = Bounded[$ubAlias, HKT]\n"
    sb ++= s"      object UpperBounded {\n"
    sb ++= s"\n"
    sb ++= s"        def of[$ubParams, HKT[$ubHkt]]: UpperBounded[$ubParams, HKT] = macro CrossQuotesMacros.typeCtor${n}Impl[$macroNothingUpper, HKT]\n"
    sb ++= s"      }\n"

    sb.toString
  }

  private def applyType2(n: Int): String = {
    val boundsPairsExplicit = (1 to n).map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)} >: ${ArityGen.lower(i)}").mkString(", ")
    val hkt = ArityGen.hktSlots(n)
    val paramBounds = (0 until n).map { i =>
      val idx = i + 1
      s"${p(i)} >: ${ArityGen.lower(idx)} <: ${ArityGen.upper(idx)}"
    }.mkString(", ")
    s"      type Apply[$boundsPairsExplicit, HKT[$hkt], $paramBounds] = HKT[${allParams(n)}]\n"
  }

  private def stubType2(n: Int): String = {
    val boundsPairsExplicit = (1 to n).map(i => s"${ArityGen.lower(i)}, ${ArityGen.upper(i)} >: ${ArityGen.lower(i)}").mkString(", ")
    val hkt = ArityGen.hktSlots(n)
    s"      type Stub[$boundsPairsExplicit, HKT[$hkt]] = HKT[${ArityGen.questionMarks(n)}]\n"
  }
}
